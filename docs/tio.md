
### tio VS netty

+ t-io是基于JVM的网络编程框架，和netty属同类
+ tio-core是基于java aio的网络编程框架
+ netty有大量公有协议的实现，t-io官方目前提供的仅有http和websocket
+ netty用到了零拷贝，这一点t-io在均衡再三之后，放弃了零拷贝，原因如下
  
  零拷贝只是改善性能的手段（或叫算法），对用户而言，框架采用什么算法并不重要，重要的是最终的目的是否达成——netty用零拷贝来改善性能，t-io自创同步安全线程池来改善性能，都是手段，殊途同归。
  零拷贝在减少拷贝过程的同时，也消耗了计算机其它资源
  堆外资源的管理势必增加t-io代码的复杂度，使t-io用户难以在源代码层驾驭t-io
  部分同类框架引入堆外资源管理后，在某些场景的确是提升了性能，但这个过程也增加了很多严重BUG
  t-io的性能已经足够好，把精力花在服务业务上，而不是性能PK场上
  
+ t-io自创了同步线程池，正是有了这个，t-io内部调度线程时就显得尤为简单，与netty的零拷贝一样，这也是改善性能与简化编程的手段，而不是最终目的。
+ t-io内置了业务数据管理能力（这是个非常重要的能力，网络编程数据绑定和释放是件极其考验开发人员水平的功能，哪怕是经验丰富的资深开发工程师也极容易死锁和OOM，甚至因此导致整个项目的失败）

+ 带上业务进行PK时，t-io性能经常优于netty，这其中的原因大概就是：用netty需要自己写代码完成业务数据的管理、流量监控等工作，而这些工作拖了裸netty的后腿，而这些工作已经被t-io内置了，所以给t-io带来的性能损耗就很有限
+ t-io不止是网络框架，更是一个网络中台，已经做了很多常用业务上的事了

+ t-io提供了极其便捷的阻塞发送、同步发送，这些能力在netty中貌似没有，需要用户写较多的代码才能实现
  
  阻塞发送：消息发送到对方后，才往下执行代码
  同步发送：对方收到消息，并回了同样的synSeq消息，才往下执行代码


----

ByteBuffer是nio/aio编程所必须掌握的一个数据结构，也是掌握tio所必须要学会的基础知识。

设想你不懂Map，不懂List，不懂Set，那么你在编程领域将会一事无成，同样的道理，如果你不懂ByteBuffer，你无法在nio/aio编程领域立足


初识ByteBuffer
我们可以把bytebuffer理解成如下几个属性组成的一个数据结构

byte[] bytes: 用来存储数据
int capacity: 用来表示bytes的容量，那么可以想像capacity就等于bytes.size()，此值在初始化bytes后，是不可变的。
int limit: 用来表示bytes实际装了多少数据，可以容易想像得到limit <= capacity，此值是可灵活变动的
int position: 用来表示在哪个位置开始往bytes写数据或是读数据，此值是可灵活变动的

----


http协议是一来一回的，所以正常场景是不会有粘包的，但pipeline模式下是允许一方连续发多个请求的，所以会有粘包产生


----

结论如下
0-10万连接。内存变化较大。主要是由于内存初始化时jvm会占用一部分内存。
10万之后。每增加10万连接 内存占用率上升300M左右。
随着连接数增加可以发现cpu性能对连接数影响不大。
新生代内存与老生代内存占用率比较合理。
并发30W连接在2小时内。内存变化不明显。处于合理状态
根据以上数据可以推论 —-> 以8G内存(可使用内存为7.5G左右)为例:当内存占用率达到5G左右时足以支撑100W并发连接。

-----

用t-io跑出每秒610万条聊天消息

参数设置
如果想跑出好的成绩，总连接数大约保持在50-300间
总连接数过多或过少，不太容易跑出600万以上的数据，但是跑出100多万的连接数的范围是非常大的，各位可以亲测一下
当然跑出啥成绩，还跟你的机器性能有关

------

好多付费，算了。。


  